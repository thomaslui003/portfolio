[{"/Users/thomaslui/Desktop/portfolio-main/src/components/About.tsx":"1","/Users/thomaslui/Desktop/portfolio-main/src/components/Experience.tsx":"2","/Users/thomaslui/Desktop/portfolio-main/src/components/ExperienceCard.tsx":"3","/Users/thomaslui/Desktop/portfolio-main/src/components/Footer.tsx":"4","/Users/thomaslui/Desktop/portfolio-main/src/components/Intro.tsx":"5","/Users/thomaslui/Desktop/portfolio-main/src/components/Navbar.tsx":"6","/Users/thomaslui/Desktop/portfolio-main/src/components/ProfileIcons.tsx":"7","/Users/thomaslui/Desktop/portfolio-main/src/components/Project.tsx":"8","/Users/thomaslui/Desktop/portfolio-main/src/components/ProjectCard.tsx":"9","/Users/thomaslui/Desktop/portfolio-main/src/components/Role.tsx":"10","/Users/thomaslui/Desktop/portfolio-main/src/components/Tag.tsx":"11","/Users/thomaslui/Desktop/portfolio-main/src/components/VanillaThreeScene.tsx":"12","/Users/thomaslui/Desktop/portfolio-main/src/pages/_app.tsx":"13","/Users/thomaslui/Desktop/portfolio-main/src/pages/_document.tsx":"14","/Users/thomaslui/Desktop/portfolio-main/src/pages/api/hello.ts":"15","/Users/thomaslui/Desktop/portfolio-main/src/pages/index.tsx":"16"},{"size":1735,"mtime":1745576897430,"results":"17","hashOfConfig":"18"},{"size":2888,"mtime":1745558402972,"results":"19","hashOfConfig":"18"},{"size":790,"mtime":1732159629000,"results":"20","hashOfConfig":"18"},{"size":335,"mtime":1732159629000,"results":"21","hashOfConfig":"18"},{"size":1516,"mtime":1746299958652,"results":"22","hashOfConfig":"18"},{"size":4461,"mtime":1745510652486,"results":"23","hashOfConfig":"18"},{"size":738,"mtime":1745490851449,"results":"24","hashOfConfig":"18"},{"size":7222,"mtime":1746292529865,"results":"25","hashOfConfig":"18"},{"size":3277,"mtime":1746356273863,"results":"26","hashOfConfig":"18"},{"size":847,"mtime":1732159629000,"results":"27","hashOfConfig":"18"},{"size":1819,"mtime":1746355954566,"results":"28","hashOfConfig":"18"},{"size":8852,"mtime":1745838957408,"results":"29","hashOfConfig":"18"},{"size":781,"mtime":1746266704028,"results":"30","hashOfConfig":"18"},{"size":233,"mtime":1732159629000,"results":"31","hashOfConfig":"18"},{"size":305,"mtime":1732159629000,"results":"32","hashOfConfig":"18"},{"size":2364,"mtime":1745837286439,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"tbe670",{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","suppressedMessages":"63","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","suppressedMessages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},{"filePath":"71","messages":"72","suppressedMessages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","suppressedMessages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"77","messages":"78","suppressedMessages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","suppressedMessages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/thomaslui/Desktop/portfolio-main/src/components/About.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/Experience.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/ExperienceCard.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/Footer.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/Intro.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/Navbar.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/ProfileIcons.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/Project.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/ProjectCard.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/Role.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/Tag.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/components/VanillaThreeScene.tsx",["83"],[],"import { useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\n\nconst VanillaThreeScene = () => {\n  const mountRef = useRef<HTMLDivElement>(null);\n  const [error, setError] = useState<string>('');\n  const mouseX = useRef(0);\n  const mouseY = useRef(0);\n  const targetRotationY = useRef(Math.PI / 4); // Initial Y rotation (45 degrees)\n  const targetRotationX = useRef(0); // Initial X rotation\n\n  useEffect(() => {\n    if (!mountRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0xf0f0f0);\n\n    // Camera setup with better initial position\n    const camera = new THREE.PerspectiveCamera(\n      45,\n      1,\n      0.1,\n      1000\n    );\n    camera.position.set(3, 2, 3);\n    camera.lookAt(0, 0, 0);\n\n    // Enhanced renderer settings for better quality\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: true,\n      alpha: true,\n      powerPreference: \"high-performance\",\n    });\n    \n    // Mouse move handler\n    const handleMouseMove = (event: MouseEvent) => {\n      // Calculate mouse position relative to container\n      const rect = mountRef.current?.getBoundingClientRect();\n      if (!rect) return;\n      \n      // Convert mouse position to normalized coordinates (-1 to 1)\n      mouseX.current = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n      mouseY.current = ((event.clientY - rect.top) / rect.height) * 2 - 1;\n      \n      // Map mouse position to Y rotation range (left/right)\n      const minRotationY = (-15 * Math.PI) / 180;  // -45 degrees (facing left)\n      const maxRotationY = (105 * Math.PI) / 180;  // 135 degrees (facing right)\n      const baseRotationY = Math.PI / 4; // 45 degrees initial rotation\n      const rotationRangeY = Math.PI;  // 180 degrees total range\n      \n      targetRotationY.current = baseRotationY + (mouseX.current * rotationRangeY/2);\n      \n      // Clamp Y rotation\n      targetRotationY.current = Math.max(minRotationY, Math.min(maxRotationY, targetRotationY.current));\n\n      // Map vertical mouse position to X rotation (up/down tilt)\n      const minRotationX = (-10 * Math.PI) / 180;  // -25 degrees tilt back\n      const maxRotationX = (10 * Math.PI) / 180;   // 25 degrees tilt forward\n      \n      // Calculate X rotation based on mouse Y position and current Y rotation\n      // This ensures the tilt direction makes sense regardless of which way the model is facing\n      const normalizedY = (targetRotationY.current - minRotationY) / (maxRotationY - minRotationY); // 0 to 1\n      const tiltDirection = normalizedY > 0.5 ? 1 : -1; // Flip tilt direction based on facing\n      \n      // Invert mouseY for natural tilt direction and adjust based on facing direction\n      targetRotationX.current = -mouseY.current * (maxRotationX - minRotationX) / 2 * tiltDirection;\n      \n      // Clamp X rotation\n      targetRotationX.current = Math.max(minRotationX, Math.min(maxRotationX, targetRotationX.current));\n    };\n\n    // Enable shadow mapping\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    \n    // Set pixel ratio for sharper rendering\n    renderer.setPixelRatio(window.devicePixelRatio);\n    \n    // Enable tone mapping for better color reproduction\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 1.0;\n    \n    // Enable color space for better color accuracy\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    \n    const container = mountRef.current;\n    const width = container.clientWidth;\n    const height = container.clientHeight;\n    renderer.setSize(width, height);\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    mountRef.current.appendChild(renderer.domElement);\n\n    // Enhanced lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 3.5);\n    scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 3.5);\n    directionalLight.position.set(5, 5, 5);\n    directionalLight.castShadow = true;\n    directionalLight.shadow.mapSize.width = 2048;\n    directionalLight.shadow.mapSize.height = 2048;\n    directionalLight.shadow.camera.near = 0.1;\n    directionalLight.shadow.camera.far = 500;\n    scene.add(directionalLight);\n\n    // Add a second directional light from a different angle for better coverage\n    const secondaryLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    secondaryLight.position.set(-5, 3, -5);\n    scene.add(secondaryLight);\n\n    // Load GLTF model with enhanced settings\n    const gltfLoader = new GLTFLoader();\n    gltfLoader.load(\n      '/models/person.glb',\n      (gltf) => {\n        console.log('Model loaded successfully:', gltf);\n        \n        const model = gltf.scene;\n        \n        // Enable shadows for all meshes in the model\n        model.traverse((node) => {\n          if (node instanceof THREE.Mesh) {\n            node.castShadow = true;\n            node.receiveShadow = true;\n            \n            // Enhance material quality if it exists\n            if (node.material) {\n              node.material.envMapIntensity = 1.0;\n              node.material.needsUpdate = true;\n              \n              // If it's a standard material, enhance its properties\n              if (node.material instanceof THREE.MeshStandardMaterial) {\n                node.material.roughness = 0.5;\n                node.material.metalness = 0.5;\n              }\n            }\n          }\n        });\n        \n        // Center the model\n        const box = new THREE.Box3().setFromObject(model);\n        const center = box.getCenter(new THREE.Vector3());\n        \n        // Create a group to act as a pivot point\n        const group = new THREE.Group();\n        scene.add(group);\n\n        // Move the model to center it at origin and offset it to the right\n        model.position.x = -center.x;\n        model.position.y = -center.y + 0.8;\n        model.position.z = -center.z;\n\n        // Get model size and scale appropriately\n        const size = box.getSize(new THREE.Vector3());\n        const maxDim = Math.max(size.x, size.y, size.z);\n        const scale = 2 / maxDim;\n        model.scale.multiplyScalar(scale);\n\n        // Add model to the group and offset the group to adjust rotation point\n        group.add(model);\n        group.position.y = 0.3;\n\n        // Initial rotation\n        group.rotation.y = Math.PI / 4;\n        group.rotation.x = 0;\n\n        // Smooth animation loop\n        const animate = () => {\n          requestAnimationFrame(animate);\n          \n          // Smoothly interpolate current rotation to target rotation for both axes\n          const rotationSpeed = 0.1;\n          group.rotation.y += (targetRotationY.current - group.rotation.y) * rotationSpeed;\n          group.rotation.x += (targetRotationX.current - group.rotation.x) * rotationSpeed;\n          \n          renderer.render(scene, camera);\n        };\n        animate();\n\n        // Add mouse move listener\n        window.addEventListener('mousemove', handleMouseMove);\n\n        // Log position for debugging\n        console.log('Model position:', model.position);\n        console.log('Group position:', group.position);\n        console.log('Model scale:', model.scale);\n        console.log('Model bounds:', box.min, box.max);\n      },\n      (xhr) => {\n        console.log((xhr.loaded / xhr.total) * 100 + '% loaded');\n      },\n      (err: unknown) => {\n        console.error('Error loading model:', err);\n        setError('Error loading model: ' + (err instanceof Error ? err.message : String(err)));\n      }\n    );\n\n    // Handle container resize\n    const handleResize = () => {\n      if (!mountRef.current) return;\n      \n      const width = mountRef.current.clientWidth;\n      const height = mountRef.current.clientHeight;\n      \n      camera.aspect = width / height;\n      camera.updateProjectionMatrix();\n      renderer.setSize(width, height);\n      renderer.setPixelRatio(window.devicePixelRatio);\n    };\n    \n    const resizeObserver = new ResizeObserver(handleResize);\n    resizeObserver.observe(container);\n\n    return () => {\n      window.removeEventListener('mousemove', handleMouseMove);\n      resizeObserver.disconnect();\n      mountRef.current?.removeChild(renderer.domElement);\n      scene.clear();\n    };\n  }, []);\n\n  return (\n    <div ref={mountRef} style={{ width: '100%', height: '100%' }}>\n      {error && (\n        <div style={{ \n          position: 'absolute', \n          top: '50%', \n          left: '50%', \n          transform: 'translate(-50%, -50%)',\n          color: 'red',\n          background: 'rgba(255, 255, 255, 0.8)',\n          padding: '10px',\n          borderRadius: '5px'\n        }}>\n          {error}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VanillaThreeScene; ","/Users/thomaslui/Desktop/portfolio-main/src/pages/_app.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/pages/_document.tsx",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/pages/api/hello.ts",[],[],"/Users/thomaslui/Desktop/portfolio-main/src/pages/index.tsx",[],[],{"ruleId":"84","severity":1,"message":"85","line":220,"column":16,"nodeType":"86","endLine":220,"endColumn":23},"react-hooks/exhaustive-deps","The ref value 'mountRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'mountRef.current' to a variable inside the effect, and use that variable in the cleanup function.","Identifier"]